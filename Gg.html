<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screw Studio - Instant Export</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.all.min.js"></script>
    <style>
        body { background-color: #030303; color: #fff; font-family: 'Inter', sans-serif; }
        .fx-card { background: #0a0a0a; border: 1px solid #1a1a1a; }
        
        input[type="range"] {
            height: 4px;
            -webkit-appearance: none;
            background: #1a1a1a;
            border-radius: 10px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
        }
        
        #progressSlider { height: 6px; background: #222; }
        #progressSlider::-webkit-slider-thumb { width: 16px; height: 16px; background: #fff; }

        .knob-label { font-size: 8px; font-weight: 800; color: #444; text-transform: uppercase; letter-spacing: 0.1em; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div class="max-w-2xl w-full fx-card rounded-[2.5rem] p-8 md:p-12 shadow-2xl relative">
        <!-- Header -->
        <div class="flex justify-between items-center mb-8 border-b border-white/5 pb-6">
            <div>
                <h1 class="text-2xl font-black italic tracking-tighter">SCREW<span class="text-blue-600">STUDIO</span></h1>
                <p class="text-[9px] text-gray-600 font-bold uppercase tracking-[0.3em]">Direct Download Mode</p>
            </div>
            <div class="flex items-center gap-2">
                <span id="timeDisplay" class="text-[10px] font-mono text-blue-500 font-bold">0:00 / 0:00</span>
            </div>
        </div>

        <!-- Import -->
        <div id="importArea" class="mb-8">
            <input type="file" id="audioInput" accept="audio/*" class="hidden">
            <button onclick="document.getElementById('audioInput').click()" class="w-full py-4 bg-white text-black rounded-2xl font-black text-[10px] uppercase tracking-widest hover:bg-gray-200 transition-all active:scale-95">
                Escolher Ficheiro
            </button>
        </div>

        <div id="mainUI" class="hidden space-y-8 opacity-0 transition-opacity duration-700">
            
            <!-- Scrubber -->
            <div class="space-y-2">
                <input type="range" id="progressSlider" class="w-full cursor-pointer" min="0" max="100" value="0" step="0.1">
            </div>

            <!-- Controls -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Engine -->
                <div class="space-y-6 bg-white/5 p-6 rounded-3xl">
                    <h3 class="knob-label">Engine Core</h3>
                    <div class="space-y-4">
                        <div class="flex justify-between"><span class="text-[10px] text-gray-400">PITCH</span><span id="pVal" class="text-blue-500 font-mono text-[10px]">1.00x</span></div>
                        <input type="range" id="pSlider" class="w-full" min="0.1" max="5.0" step="0.01" value="1.0">
                        <div class="flex justify-between"><span class="text-[10px] text-gray-400">TEMPO</span><span id="tVal" class="text-blue-500 font-mono text-[10px]">1.00x</span></div>
                        <input type="range" id="tSlider" class="w-full" min="0.1" max="2.0" step="0.01" value="1.0">
                        <div class="flex items-center justify-between pt-2">
                            <span class="text-[10px] text-gray-400 uppercase font-bold tracking-tighter">Reverse</span>
                            <button id="revBtn" class="px-4 py-1.5 bg-white/5 border border-white/10 rounded-full text-[9px] font-black uppercase">OFF</button>
                        </div>
                    </div>
                </div>

                <!-- FX -->
                <div class="space-y-6 bg-white/5 p-6 rounded-3xl">
                    <h3 class="knob-label">FX Rack</h3>
                    <div class="space-y-4">
                        <div class="space-y-1">
                            <div class="flex justify-between"><span class="text-[10px] text-gray-400 italic">LOW-PASS</span><span id="fVal" class="text-blue-500 font-mono text-[10px]">MAX</span></div>
                            <input type="range" id="fSlider" class="w-full" min="200" max="20000" step="1" value="20000">
                        </div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><span class="text-[10px] text-gray-400 italic">REVERB</span><span id="rVal" class="text-blue-500 font-mono text-[10px]">0%</span></div>
                            <input type="range" id="rSlider" class="w-full" min="0" max="1" step="0.01" value="0">
                        </div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><span class="text-[10px] text-gray-400 italic">CRUNCH</span><span id="dVal" class="text-blue-500 font-mono text-[10px]">0%</span></div>
                            <input type="range" id="dSlider" class="w-full" min="0" max="50" step="1" value="0">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="flex flex-col md:flex-row gap-4">
                <select id="format" class="bg-black border border-white/10 text-white px-6 py-4 rounded-2xl text-[10px] font-bold uppercase outline-none focus:border-blue-500">
                    <option value="wav">WAV (Rápido)</option>
                    <option value="mp3">MP3 (320k)</option>
                </select>
                <button id="playBtn" class="flex-1 py-4 bg-gray-900 text-white rounded-2xl font-black text-[10px] uppercase hover:bg-gray-800 transition-all">Play / Pause</button>
                <button id="exportBtn" class="flex-1 py-4 bg-blue-600 text-white rounded-2xl font-black text-[10px] uppercase hover:bg-blue-500">Download Direto</button>
            </div>
        </div>
    </div>

    <script>
        let audioBuffer = null, audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let sourceNode = null, filterNode, reverbNode, distortionNode, dryGain, wetGain;
        let isPlaying = false, isReverse = false, startTime = 0, offsetTime = 0, aniFrame;

        const input = document.getElementById('audioInput'), mainUI = document.getElementById('mainUI');
        const playBtn = document.getElementById('playBtn'), exportBtn = document.getElementById('exportBtn'), revBtn = document.getElementById('revBtn');
        const pS = document.getElementById('pSlider'), tS = document.getElementById('tSlider'), fS = document.getElementById('fSlider'), rS = document.getElementById('rSlider'), dS = document.getElementById('dSlider');
        const pV = document.getElementById('pVal'), tV = document.getElementById('tVal'), fV = document.getElementById('fVal'), rV = document.getElementById('rVal'), dV = document.getElementById('dVal');
        const progressSlider = document.getElementById('progressSlider'), timeDisplay = document.getElementById('timeDisplay');

        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const ab = await file.arrayBuffer();
            audioBuffer = await audioCtx.decodeAudioData(ab);
            mainUI.classList.remove('hidden');
            setTimeout(() => mainUI.classList.add('opacity-100'), 50);
            updateUI();
        };

        const updateUI = () => {
            pV.innerText = parseFloat(pS.value).toFixed(2) + "x";
            tV.innerText = parseFloat(tS.value).toFixed(2) + "x";
            fV.innerText = fS.value >= 19000 ? "MAX" : fS.value + "Hz";
            rV.innerText = Math.round(rS.value * 100) + "%";
            dV.innerText = Math.round(dS.value * 2) + "%";
            
            const total = audioBuffer ? audioBuffer.duration : 0;
            timeDisplay.innerText = `${fmt(offsetTime)} / ${fmt(total)}`;
            progressSlider.max = total;
            if(!isDragging) progressSlider.value = offsetTime;

            if (isPlaying && sourceNode) {
                sourceNode.playbackRate.value = pS.value * tS.value;
                filterNode.frequency.setTargetAtTime(fS.value, audioCtx.currentTime, 0.05);
                wetGain.gain.setTargetAtTime(rS.value, audioCtx.currentTime, 0.05);
                dryGain.gain.setTargetAtTime(1 - rS.value * 0.5, audioCtx.currentTime, 0.05);
                distortionNode.curve = makeDistortionCurve(dS.value);
            }
        };

        [pS, tS, fS, rS, dS].forEach(s => s.oninput = updateUI);

        function fmt(s) { return `${Math.floor(s/60)}:${Math.floor(s%60).toString().padStart(2,'0')}`; }
        function makeDistortionCurve(amount) {
            const n = 44100, curve = new Float32Array(n), deg = Math.PI / 180;
            for (let i = 0; i < n; ++i) { const x = (i * 2) / n - 1; curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x)); }
            return curve;
        }

        let isDragging = false;
        progressSlider.onmousedown = () => isDragging = true;
        progressSlider.onmouseup = () => { isDragging = false; offsetTime = parseFloat(progressSlider.value); if (isPlaying) { stop(); start(); } };

        revBtn.onclick = () => { isReverse = !isReverse; revBtn.innerText = isReverse ? "ON" : "OFF"; revBtn.classList.toggle('bg-red-600', isReverse); if (isPlaying) { stop(); start(); } };

        playBtn.onclick = () => isPlaying ? stop() : start();

        function start() {
            if (!audioBuffer) return;
            sourceNode = audioCtx.createBufferSource();
            sourceNode.buffer = isReverse ? reverseBuffer(audioBuffer) : audioBuffer;
            
            filterNode = audioCtx.createBiquadFilter(); filterNode.type = "lowpass"; filterNode.frequency.value = fS.value;
            distortionNode = audioCtx.createWaveShaper(); distortionNode.curve = makeDistortionCurve(dS.value);
            reverbNode = audioCtx.createConvolver(); reverbNode.buffer = createReverb();
            dryGain = audioCtx.createGain(); wetGain = audioCtx.createGain();
            dryGain.gain.value = 1 - rS.value * 0.5; wetGain.gain.value = rS.value;

            sourceNode.connect(filterNode); filterNode.connect(distortionNode); distortionNode.connect(dryGain);
            dryGain.connect(audioCtx.destination); distortionNode.connect(reverbNode); reverbNode.connect(wetGain);
            wetGain.connect(audioCtx.destination);

            sourceNode.playbackRate.value = pS.value * tS.value;
            let playAt = isReverse ? audioBuffer.duration - offsetTime : offsetTime;
            sourceNode.start(0, Math.max(0, playAt));
            startTime = audioCtx.currentTime;
            isPlaying = true;
            playBtn.innerText = "Pausa";
            animate();
        }

        function stop() {
            if (sourceNode) {
                const elapsed = (audioCtx.currentTime - startTime) * (pS.value * tS.value);
                offsetTime += elapsed;
                sourceNode.stop();
                sourceNode = null;
            }
            cancelAnimationFrame(aniFrame);
            isPlaying = false;
            playBtn.innerText = "Reproduzir";
        }

        function animate() {
            if (!isPlaying) return;
            const rate = pS.value * tS.value;
            const current = offsetTime + (audioCtx.currentTime - startTime) * rate;
            if (current >= audioBuffer.duration) { offsetTime = 0; stop(); updateUI(); return; }
            if (!isDragging) { progressSlider.value = current; timeDisplay.innerText = `${fmt(current)} / ${fmt(audioBuffer.duration)}`; }
            aniFrame = requestAnimationFrame(animate);
        }

        function reverseBuffer(buffer) {
            const out = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                const d = buffer.getChannelData(i), o = out.getChannelData(i);
                for (let j = 0; j < buffer.length; j++) o[j] = d[buffer.length - 1 - j];
            }
            return out;
        }

        function createReverb() {
            const len = audioCtx.sampleRate * 2, imp = audioCtx.createBuffer(2, len, audioCtx.sampleRate);
            for (let i = 0; i < 2; i++) { const c = imp.getChannelData(i); for (let j = 0; j < len; j++) c[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 2); }
            return imp;
        }

        // DOWNLOAD DIRETO - SEM OVERLAYS, SEM ESPERAS VISÍVEIS
        exportBtn.onclick = async () => {
            if (!audioBuffer) return;
            const rate = pS.value * tS.value;
            const format = document.getElementById('format').value;
            
            // Renderização em background instantânea
            const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, Math.floor(audioBuffer.sampleRate * (audioBuffer.duration / rate)), audioBuffer.sampleRate);
            const oSource = offlineCtx.createBufferSource();
            oSource.buffer = isReverse ? reverseBuffer(audioBuffer) : audioBuffer;
            oSource.playbackRate.value = rate;

            const oFilter = offlineCtx.createBiquadFilter(); oFilter.type = "lowpass"; oFilter.frequency.value = fS.value;
            const oDist = offlineCtx.createWaveShaper(); oDist.curve = makeDistortionCurve(dS.value);
            const oRev = offlineCtx.createConvolver(); oRev.buffer = createReverb();
            const oDry = offlineCtx.createGain(); const oWet = offlineCtx.createGain();
            oDry.gain.value = 1 - rS.value * 0.5; oWet.gain.value = rS.value;

            oSource.connect(oFilter); oFilter.connect(oDist); oDist.connect(oDry); oDry.connect(offlineCtx.destination);
            oDist.connect(oRev); oRev.connect(oWet); oWet.connect(offlineCtx.destination);
            oSource.start();

            const rendered = await offlineCtx.startRendering();
            const blob = (format === 'mp3') ? await encodeMP3(rendered) : bufferToWav(rendered);

            // Disparo de download silencioso
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `direct_screw_${Date.now()}.${format}`;
            link.click();
        };

        async function encodeMP3(ab) {
            return new Promise(res => {
                const mp3encoder = new lamejs.Mp3Encoder(ab.numberOfChannels, ab.sampleRate, 320);
                const mp3Data = [];
                const samplesL = ab.getChannelData(0), samplesR = ab.numberOfChannels > 1 ? ab.getChannelData(1) : samplesL;
                const conv = (s) => {
                    const i16 = new Int16Array(s.length);
                    for (let i = 0; i < s.length; i++) {
                        let v = Math.max(-1, Math.min(1, s[i]));
                        i16[i] = v < 0 ? v * 0x8000 : v * 0x7FFF;
                    }
                    return i16;
                };
                const l = conv(samplesL), r = conv(samplesR), b = 1152;
                for (let i = 0; i < l.length; i += b) {
                    const buf = mp3encoder.encodeBuffer(l.subarray(i, i + b), r.subarray(i, i + b));
                    if (buf.length > 0) mp3Data.push(buf);
                }
                const end = mp3encoder.flush();
                if (end.length > 0) mp3Data.push(end);
                res(new Blob(mp3Data, { type: 'audio/mp3' }));
            });
        }

        function bufferToWav(ab) {
            let n = ab.numberOfChannels, len = ab.length * n * 2 + 44, b = new ArrayBuffer(len), v = new DataView(b), pos = 0;
            const u16 = (d) => { v.setUint16(pos, d, true); pos += 2; };
            const u32 = (d) => { v.setUint32(pos, d, true); pos += 4; };
            u32(0x46464952); u32(len - 8); u32(0x45564157); u32(0x20746d66); u32(16); u16(1); u16(n);
            u32(ab.sampleRate); u32(ab.sampleRate * 2 * n); u16(n * 2); u16(16); u32(0x61746164); u32(len - pos - 4);
            let offset = 0;
            while(pos < len) {
                for(let i=0; i<n; i++) {
                    let s = Math.max(-1, Math.min(1, ab.getChannelData(i)[offset]));
                    v.setInt16(pos, (s < 0 ? s * 0x8000 : s * 0x7FFF), true); pos += 2;
                }
                offset++;
            }
            return new Blob([b], {type: "audio/wav"});
        }
    </script>
</body>
</html>

