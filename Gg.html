<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Screw Studio - Motion Sound Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.all.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #020202; 
            color: white; 
            margin: 0; 
            overscroll-behavior: contain;
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        input[type="range"] { -webkit-appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            height: 18px; width: 18px; 
            border-radius: 50%; 
            background: #ffffff; 
            cursor: pointer; 
            border: 3px solid #3b82f6; 
            margin-top: -7px; 
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        input[type="range"]::-webkit-slider-runnable-track { 
            width: 100%; height: 4px; 
            cursor: pointer; 
            background: rgba(255,255,255,0.1); 
            border-radius: 2px; 
        }

        .locked-screen {
            overflow: hidden !important;
            touch-action: none !important;
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const EASING_FUNCTIONS = {
            linear: (t) => t,
            easeIn: (t) => t * t,
            easeOut: (t) => t * (2 - t),
            easeInOut: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            bounce: (t) => {
                if (t < (1 / 2.75)) return 7.5625 * t * t;
                else if (t < (2 / 2.75)) return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
                else if (t < (2.5 / 2.75)) return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
                else return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
            },
            elastic: (t) => {
                if (t === 0 || t === 1) return t;
                const p = 0.3;
                const s = p / 4;
                return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
            },
            step: (t) => t < 0.5 ? 0 : 1
        };

        const makeDistortionCurve = (amount) => {
            const n = 44100;
            const curve = new Float32Array(n);
            const deg = Math.PI / 180;
            for (let i = 0; i < n; ++i) {
                const x = (i * 2) / n - 1;
                curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
            }
            return curve;
        };

        const App = () => {
            const [audioBuffer, setAudioBuffer] = useState(null);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [isReverse, setIsReverse] = useState(false);
            const [format, setFormat] = useState('mp3');
            const [activeParam, setActiveParam] = useState('pitch');
            const [isLocked, setIsLocked] = useState(false);
            const [controlMode, setControlMode] = useState('automate');

            const [params, setParams] = useState({
                pitch: { val: 1.0, min: 0.1, max: 3.0, keys: [{ t: 0, v: 0.31, ease: 'easeInOut' }] },
                tempo: { val: 1.0, min: 0.1, max: 2.0, keys: [{ t: 0, v: 0.47, ease: 'linear' }] },
                filter: { val: 20000, min: 200, max: 20000, keys: [{ t: 0, v: 1.0, ease: 'linear' }] },
                reverb: { val: 0, min: 0, max: 1, keys: [{ t: 0, v: 0, ease: 'linear' }] },
                crunch: { val: 0, min: 0, max: 50, keys: [{ t: 0, v: 0, ease: 'linear' }] },
            });

            const audioCtx = useRef(null);
            const sourceNode = useRef(null);
            const nodes = useRef({});
            const startTimeRef = useRef(0);
            const offsetTimeRef = useRef(0);
            const requestRef = useRef();

            useEffect(() => {
                if (isLocked) document.body.classList.add('locked-screen');
                else document.body.classList.remove('locked-screen');
                return () => document.body.classList.remove('locked-screen');
            }, [isLocked]);

            useEffect(() => {
                audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
                return () => audioCtx.current.close();
            }, []);

            const getInterpolatedValue = useCallback((paramKey, time) => {
                const p = params[paramKey];
                if (controlMode === 'slide') return p.val;
                const sortedKeys = [...p.keys].sort((a, b) => a.t - b.t);
                if (sortedKeys.length === 0) return p.val;
                if (time <= sortedKeys[0].t) return sortedKeys[0].v * (p.max - p.min) + p.min;
                if (time >= sortedKeys[sortedKeys.length - 1].t) return sortedKeys[sortedKeys.length - 1].v * (p.max - p.min) + p.min;

                for (let i = 0; i < sortedKeys.length - 1; i++) {
                    const start = sortedKeys[i];
                    const end = sortedKeys[i + 1];
                    if (time >= start.t && time <= end.t) {
                        const progress = (time - start.t) / (end.t - start.t || 0.001);
                        const eased = EASING_FUNCTIONS[start.ease || 'linear'](progress);
                        return (start.v + (end.v - start.v) * eased) * (p.max - p.min) + p.min;
                    }
                }
                return p.val;
            }, [params, controlMode]);

            const updateAudioNodes = useCallback((time) => {
                if (!isPlaying || !nodes.current.filter) return;
                const targetTime = audioCtx.current.currentTime;
                const currentPitch = getInterpolatedValue('pitch', time);
                const currentTempo = getInterpolatedValue('tempo', time);
                
                sourceNode.current.playbackRate.setTargetAtTime(currentPitch * currentTempo, targetTime, 0.05);
                nodes.current.filter.frequency.setTargetAtTime(getInterpolatedValue('filter', time), targetTime, 0.05);
                nodes.current.wetGain.gain.setTargetAtTime(getInterpolatedValue('reverb', time), targetTime, 0.05);
                nodes.current.dryGain.gain.setTargetAtTime(1 - getInterpolatedValue('reverb', time) * 0.5, targetTime, 0.05);
                nodes.current.dist.curve = makeDistortionCurve(getInterpolatedValue('crunch', time));
            }, [isPlaying, getInterpolatedValue]);

            const animate = useCallback(() => {
                if (!isPlaying) return;
                const pitch = getInterpolatedValue('pitch', currentTime);
                const tempo = getInterpolatedValue('tempo', currentTime);
                const elapsed = (audioCtx.current.currentTime - startTimeRef.current) * (pitch * tempo);
                
                let nextTime = offsetTimeRef.current + elapsed;
                
                if (nextTime >= duration) {
                    handleStop(true);
                    return;
                }
                
                setCurrentTime(nextTime);
                updateAudioNodes(nextTime);
                requestRef.current = requestAnimationFrame(animate);
            }, [isPlaying, duration, currentTime, getInterpolatedValue, updateAudioNodes]);

            useEffect(() => {
                if (isPlaying) requestRef.current = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(requestRef.current);
            }, [isPlaying, animate]);

            const handleFileUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const buffer = await audioCtx.current.decodeAudioData(await file.arrayBuffer());
                setAudioBuffer(buffer);
                setDuration(buffer.duration);
                setCurrentTime(0);
                setIsPlaying(false);
            };

            const getProcessedBuffer = () => {
                if (!isReverse) return audioBuffer;
                const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(
                    audioBuffer.numberOfChannels,
                    audioBuffer.length,
                    audioBuffer.sampleRate
                );
                const reversed = offlineCtx.createBuffer(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
                for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
                    const chanData = audioBuffer.getChannelData(i);
                    const revChanData = reversed.getChannelData(i);
                    for (let j = 0; j < audioBuffer.length; j++) {
                        revChanData[j] = chanData[audioBuffer.length - 1 - j];
                    }
                }
                return reversed;
            };

            const handleStart = () => {
                if (!audioBuffer) return;
                if (audioCtx.current.state === 'suspended') audioCtx.current.resume();
                
                sourceNode.current = audioCtx.current.createBufferSource();
                sourceNode.current.buffer = getProcessedBuffer();
                
                nodes.current.filter = audioCtx.current.createBiquadFilter();
                nodes.current.dist = audioCtx.current.createWaveShaper();
                nodes.current.dryGain = audioCtx.current.createGain();
                nodes.current.wetGain = audioCtx.current.createGain();
                nodes.current.reverb = audioCtx.current.createConvolver();
                
                const reverbLen = audioCtx.current.sampleRate * 2;
                const imp = audioCtx.current.createBuffer(2, reverbLen, audioCtx.current.sampleRate);
                for (let i = 0; i < 2; i++) {
                    const c = imp.getChannelData(i);
                    for (let j = 0; j < reverbLen; j++) c[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / reverbLen, 2);
                }
                nodes.current.reverb.buffer = imp;

                sourceNode.current.connect(nodes.current.filter);
                nodes.current.filter.connect(nodes.current.dist);
                nodes.current.dist.connect(nodes.current.dryGain);
                nodes.current.dryGain.connect(audioCtx.current.destination);
                nodes.current.dist.connect(nodes.current.reverb);
                nodes.current.reverb.connect(nodes.current.wetGain);
                nodes.current.wetGain.connect(audioCtx.current.destination);

                // Se reverso, o tempo de início no buffer também é "invertido"
                const startAt = isReverse ? (duration - currentTime) : currentTime;
                sourceNode.current.start(0, Math.max(0, startAt));
                
                startTimeRef.current = audioCtx.current.currentTime;
                offsetTimeRef.current = currentTime;
                setIsPlaying(true);
            };

            const handleStop = (reset = false) => {
                if (sourceNode.current) {
                    try { sourceNode.current.stop(); } catch(e) {}
                    sourceNode.current = null;
                }
                if (reset) {
                    setCurrentTime(0);
                    offsetTimeRef.current = 0;
                } else {
                    offsetTimeRef.current = currentTime;
                }
                setIsPlaying(false);
            };

            const handleExport = async () => {
                if (!audioBuffer) return;
                handleStop();
                const offlineCtx = new OfflineAudioContext(1, Math.floor(audioBuffer.sampleRate * duration), audioBuffer.sampleRate);
                const oSource = offlineCtx.createBufferSource();
                oSource.buffer = getProcessedBuffer();
                oSource.playbackRate.value = getInterpolatedValue('pitch', duration/2) * getInterpolatedValue('tempo', duration/2);
                oSource.connect(offlineCtx.destination);
                oSource.start();
                const rendered = await offlineCtx.startRendering();
                
                const encoder = new lamejs.Mp3Encoder(1, rendered.sampleRate, 128);
                const samples = rendered.getChannelData(0);
                const i16 = new Int16Array(samples.length);
                for (let i = 0; i < samples.length; i++) {
                    let v = Math.max(-1, Math.min(1, samples[i]));
                    i16[i] = v < 0 ? v * 0x8000 : v * 0x7FFF;
                }
                const mp3Data = [encoder.encodeBuffer(i16), encoder.flush()];
                const blob = new Blob(mp3Data, { type: 'audio/mp3' });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `screw_studio_render_${Date.now()}.mp3`;
                a.click();
            };

            const GraphEditor = ({ paramKey, isLocked }) => {
                const canvasRef = useRef(null);
                const [draggingIdx, setDraggingIdx] = useState(null);
                const p = params[paramKey];

                const getMousePos = (e) => {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
                    const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
                    return { x: (clientX - rect.left) / rect.width, y: 1 - (clientY - rect.top) / rect.height };
                };

                const handleStart = (e) => {
                    if (!isLocked) return;
                    const pos = getMousePos(e);
                    const time = pos.x * duration;
                    const val = pos.y;
                    
                    // Verifica se clicou em um ponto existente
                    const threshold = 0.04;
                    const foundIdx = p.keys.findIndex(k => 
                        Math.abs((k.t / duration) - pos.x) < threshold && Math.abs(k.v - val) < threshold
                    );

                    if (foundIdx !== -1) {
                        setDraggingIdx(foundIdx);
                    } else {
                        // Cria novo ponto
                        const newKey = { t: time, v: val, ease: 'linear' };
                        const newKeys = [...p.keys, newKey].sort((a,b) => a.t - b.t);
                        const newIdx = newKeys.findIndex(k => k.t === time);
                        setParams(prev => ({
                            ...prev,
                            [paramKey]: { ...prev[paramKey], keys: newKeys }
                        }));
                        setDraggingIdx(newIdx);
                    }
                };

                const handleMove = useCallback((e) => {
                    if (draggingIdx === null) return;
                    if (e.cancelable) e.preventDefault();
                    const pos = getMousePos(e);
                    
                    setParams(prev => {
                        const newKeys = [...prev[paramKey].keys];
                        newKeys[draggingIdx] = { 
                            ...newKeys[draggingIdx], 
                            t: Math.max(0, Math.min(duration, pos.x * duration)), 
                            v: Math.max(0, Math.min(1, pos.y)) 
                        };
                        return { ...prev, [paramKey]: { ...prev[paramKey], keys: newKeys } };
                    });
                }, [draggingIdx, duration, paramKey]);

                const handleEnd = useCallback(() => {
                    if (draggingIdx !== null) {
                        setParams(prev => ({
                            ...prev,
                            [paramKey]: { 
                                ...prev[paramKey], 
                                keys: [...prev[paramKey].keys].sort((a,b) => a.t - b.t) 
                            }
                        }));
                        setDraggingIdx(null);
                    }
                }, [draggingIdx, paramKey]);

                useEffect(() => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    const sortedKeys = [...p.keys].sort((a,b) => a.t - b.t);

                    // Desenha a linha de interpolação
                    ctx.beginPath();
                    ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 4;
                    sortedKeys.forEach((k, i) => {
                        const x = (k.t / duration) * canvas.width;
                        const y = (1 - k.v) * canvas.height;
                        if (i === 0) ctx.moveTo(x, y);
                        else {
                            const prev = sortedKeys[i-1];
                            const easing = EASING_FUNCTIONS[prev.ease || 'linear'];
                            const samples = 40;
                            for(let s=0; s<=samples; s++) {
                                const t = s/samples;
                                const curT = prev.t + (k.t - prev.t) * t;
                                const curV = prev.v + (k.v - prev.v) * easing(t);
                                ctx.lineTo((curT/duration)*canvas.width, (1-curV)*canvas.height);
                            }
                        }
                    });
                    ctx.stroke();

                    // Desenha os círculos brancos (Keyframes)
                    p.keys.forEach((k, i) => {
                        const x = (k.t / duration) * canvas.width;
                        const y = (1 - k.v) * canvas.height;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = (i === draggingIdx) ? '#3b82f6' : '#000000';
                        ctx.lineWidth = (i === draggingIdx) ? 3 : 2;
                        ctx.stroke();
                    });

                    // Playhead
                    const px = (currentTime / duration) * canvas.width;
                    ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(px, 0); ctx.lineTo(px, canvas.height); ctx.stroke();
                }, [p.keys, currentTime, duration, draggingIdx]);

                return (
                    <div className="space-y-6">
                        <div className="relative">
                            <canvas 
                                ref={canvasRef} width={800} height={240} 
                                onMouseDown={handleStart} onMouseMove={handleMove} onMouseUp={handleEnd}
                                onTouchStart={handleStart} onTouchMove={handleMove} onTouchEnd={handleEnd}
                                className={`w-full h-64 bg-black/5
