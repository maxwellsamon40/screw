<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screw Studio - Light Export</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.all.min.js"></script>
    <style>
        body { background-color: #030303; color: #fff; font-family: 'Inter', sans-serif; }
        .fx-card { background: #0a0a0a; border: 1px solid #1a1a1a; }
        input[type="range"] { height: 4px; -webkit-appearance: none; background: #1a1a1a; border-radius: 10px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #3b82f6; border-radius: 50%; cursor: pointer; }
        #progressSlider { height: 6px; background: #222; }
        #progressSlider::-webkit-slider-thumb { width: 16px; height: 16px; background: #fff; }
        .knob-label { font-size: 8px; font-weight: 800; color: #444; text-transform: uppercase; letter-spacing: 0.1em; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div class="max-w-2xl w-full fx-card rounded-[2.5rem] p-8 md:p-12 shadow-2xl relative">
        <div class="flex justify-between items-center mb-8 border-b border-white/5 pb-6">
            <div>
                <h1 class="text-2xl font-black italic tracking-tighter uppercase">Screw<span class="text-blue-600">Studio</span></h1>
                <p class="text-[9px] text-gray-600 font-bold uppercase tracking-[0.3em]">Compact Export Engine</p>
            </div>
            <div id="timeDisplay" class="text-[10px] font-mono text-blue-500 font-bold">0:00 / 0:00</div>
        </div>

        <div class="mb-8">
            <input type="file" id="audioInput" accept="audio/*" class="hidden">
            <button onclick="document.getElementById('audioInput').click()" class="w-full py-4 bg-white text-black rounded-2xl font-black text-[10px] uppercase tracking-widest hover:bg-gray-200 transition-all active:scale-95">
                Importar Áudio
            </button>
        </div>

        <div id="mainUI" class="hidden space-y-8 opacity-0 transition-opacity duration-700">
            <input type="range" id="progressSlider" class="w-full cursor-pointer" min="0" max="100" value="0" step="0.1">

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="space-y-6 bg-white/5 p-6 rounded-3xl">
                    <h3 class="knob-label">Motor Principal</h3>
                    <div class="space-y-4">
                        <div class="flex justify-between"><span class="text-[10px] text-gray-400">PITCH</span><span id="pVal" class="text-blue-500 font-mono text-[10px]">1.00x</span></div>
                        <input type="range" id="pSlider" class="w-full" min="0.1" max="3.0" step="0.01" value="1.0">
                        <div class="flex justify-between"><span class="text-[10px] text-gray-400">TEMPO</span><span id="tVal" class="text-blue-500 font-mono text-[10px]">1.00x</span></div>
                        <input type="range" id="tSlider" class="w-full" min="0.1" max="2.0" step="0.01" value="1.0">
                        <button id="revBtn" class="w-full py-2 bg-white/5 border border-white/10 rounded-xl text-[9px] font-black uppercase mt-2">Reverse: OFF</button>
                    </div>
                </div>

                <div class="space-y-6 bg-white/5 p-6 rounded-3xl">
                    <h3 class="knob-label">Rack de Efeitos</h3>
                    <div class="space-y-4">
                        <div class="space-y-1">
                            <div class="flex justify-between"><span class="text-[10px] text-gray-400">FILTRO</span><span id="fVal" class="text-blue-500 font-mono text-[10px]">MAX</span></div>
                            <input type="range" id="fSlider" class="w-full" min="200" max="20000" step="1" value="20000">
                        </div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><span class="text-[10px] text-gray-400">REVERB</span><span id="rVal" class="text-blue-500 font-mono text-[10px]">0%</span></div>
                            <input type="range" id="rSlider" class="w-full" min="0" max="1" step="0.01" value="0">
                        </div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><span class="text-[10px] text-gray-400">CRUNCH</span><span id="dVal" class="text-blue-500 font-mono text-[10px]">0%</span></div>
                            <input type="range" id="dSlider" class="w-full" min="0" max="50" step="1" value="0">
                        </div>
                    </div>
                </div>
            </div>

            <div class="flex flex-col md:flex-row gap-4">
                <select id="format" class="bg-black border border-white/10 text-white px-6 py-4 rounded-2xl text-[10px] font-bold uppercase outline-none focus:border-blue-500">
                    <option value="mp3">MP3 (Arquivo Leve - 128kbps)</option>
                    <option value="wav">WAV (Compacto - 16-bit Mono)</option>
                </select>
                <button id="playBtn" class="flex-1 py-4 bg-gray-900 text-white rounded-2xl font-black text-[10px] uppercase hover:bg-gray-800 transition-all">Play / Pause</button>
                <button id="exportBtn" class="flex-1 py-4 bg-blue-600 text-white rounded-2xl font-black text-[10px] uppercase hover:bg-blue-500 shadow-xl shadow-blue-900/40">Baixar (Otimizado)</button>
            </div>
            
            <p id="statusMsg" class="text-[9px] text-center text-gray-600 font-bold uppercase tracking-widest hidden italic">Comprimindo áudio para reduzir tamanho...</p>
        </div>
    </div>

    <script>
        let audioBuffer = null, audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let sourceNode = null, filterNode, reverbNode, distortionNode, dryGain, wetGain;
        let isPlaying = false, isReverse = false, startTime = 0, offsetTime = 0, aniFrame;

        const input = document.getElementById('audioInput'), mainUI = document.getElementById('mainUI');
        const playBtn = document.getElementById('playBtn'), exportBtn = document.getElementById('exportBtn'), revBtn = document.getElementById('revBtn');
        const pS = document.getElementById('pSlider'), tS = document.getElementById('tSlider'), fS = document.getElementById('fSlider'), rS = document.getElementById('rSlider'), dS = document.getElementById('dSlider');
        const pV = document.getElementById('pVal'), tV = document.getElementById('tVal'), fV = document.getElementById('fVal'), rV = document.getElementById('rVal'), dV = document.getElementById('dVal');
        const progressSlider = document.getElementById('progressSlider'), timeDisplay = document.getElementById('timeDisplay'), statusMsg = document.getElementById('statusMsg');

        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const ab = await file.arrayBuffer();
            audioBuffer = await audioCtx.decodeAudioData(ab);
            mainUI.classList.remove('hidden');
            setTimeout(() => mainUI.classList.add('opacity-100'), 50);
            updateUI();
        };

        const updateUI = () => {
            pV.innerText = parseFloat(pS.value).toFixed(2) + "x";
            tV.innerText = parseFloat(tS.value).toFixed(2) + "x";
            fV.innerText = fS.value >= 19000 ? "MAX" : fS.value + "Hz";
            rV.innerText = Math.round(rS.value * 100) + "%";
            dV.innerText = Math.round(dS.value * 2) + "%";
            const total = audioBuffer ? audioBuffer.duration : 0;
            timeDisplay.innerText = `${fmt(offsetTime)} / ${fmt(total)}`;
            progressSlider.max = total;
            if(!isDragging) progressSlider.value = offsetTime;
            if (isPlaying && sourceNode) {
                sourceNode.playbackRate.value = pS.value * tS.value;
                filterNode.frequency.setTargetAtTime(fS.value, audioCtx.currentTime, 0.05);
                wetGain.gain.setTargetAtTime(rS.value, audioCtx.currentTime, 0.05);
                dryGain.gain.setTargetAtTime(1 - rS.value * 0.5, audioCtx.currentTime, 0.05);
                distortionNode.curve = makeDistortionCurve(dS.value);
            }
        };

        [pS, tS, fS, rS, dS].forEach(s => s.oninput = updateUI);

        function fmt(s) { return `${Math.floor(s/60)}:${Math.floor(s%60).toString().padStart(2,'0')}`; }
        function makeDistortionCurve(amount) {
            const n = 44100, curve = new Float32Array(n), deg = Math.PI / 180;
            for (let i = 0; i < n; ++i) { const x = (i * 2) / n - 1; curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x)); }
            return curve;
        }

        let isDragging = false;
        progressSlider.onmousedown = () => isDragging = true;
        progressSlider.onmouseup = () => { isDragging = false; offsetTime = parseFloat(progressSlider.value); if (isPlaying) { stop(); start(); } };

        revBtn.onclick = () => { isReverse = !isReverse; revBtn.innerText = `Reverse: ${isReverse ? 'ON' : 'OFF'}`; revBtn.classList.toggle('text-blue-500', isReverse); if (isPlaying) { stop(); start(); } };

        playBtn.onclick = () => isPlaying ? stop() : start();

        function start() {
            if (!audioBuffer) return;
            if(audioCtx.state === 'suspended') audioCtx.resume();
            sourceNode = audioCtx.createBufferSource();
            sourceNode.buffer = isReverse ? reverseBuffer(audioBuffer) : audioBuffer;
            filterNode = audioCtx.createBiquadFilter(); filterNode.type = "lowpass"; filterNode.frequency.value = fS.value;
            distortionNode = audioCtx.createWaveShaper(); distortionNode.curve = makeDistortionCurve(dS.value);
            reverbNode = audioCtx.createConvolver(); reverbNode.buffer = createReverb();
            dryGain = audioCtx.createGain(); wetGain = audioCtx.createGain();
            dryGain.gain.value = 1 - rS.value * 0.5; wetGain.gain.value = rS.value;
            sourceNode.connect(filterNode); filterNode.connect(distortionNode); distortionNode.connect(dryGain);
            dryGain.connect(audioCtx.destination); distortionNode.connect(reverbNode); reverbNode.connect(wetGain);
            wetGain.connect(audioCtx.destination);
            sourceNode.playbackRate.value = pS.value * tS.value;
            let playAt = isReverse ? audioBuffer.duration - offsetTime : offsetTime;
            sourceNode.start(0, Math.max(0, playAt));
            startTime = audioCtx.currentTime;
            isPlaying = true;
            playBtn.innerText = "Parar";
            animate();
        }

        function stop() {
            if (sourceNode) {
                const elapsed = (audioCtx.currentTime - startTime) * (pS.value * tS.value);
                offsetTime += elapsed;
                sourceNode.stop();
                sourceNode = null;
            }
            cancelAnimationFrame(aniFrame);
            isPlaying = false;
            playBtn.innerText = "Reproduzir";
        }

        function animate() {
            if (!isPlaying) return;
            const rate = pS.value * tS.value;
            const current = offsetTime + (audioCtx.currentTime - startTime) * rate;
            if (current >= audioBuffer.duration) { offsetTime = 0; stop(); updateUI(); return; }
            if (!isDragging) { progressSlider.value = current; timeDisplay.innerText = `${fmt(current)} / ${fmt(audioBuffer.duration)}`; }
            aniFrame = requestAnimationFrame(animate);
        }

        function reverseBuffer(buffer) {
            const out = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                const d = buffer.getChannelData(i), o = out.getChannelData(i);
                for (let j = 0; j < buffer.length; j++) o[j] = d[buffer.length - 1 - j];
            }
            return out;
        }

        function createReverb() {
            const len = audioCtx.sampleRate * 2, imp = audioCtx.createBuffer(2, len, audioCtx.sampleRate);
            for (let i = 0; i < 2; i++) { const c = imp.getChannelData(i); for (let j = 0; j < len; j++) c[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / len, 2); }
            return imp;
        }

        // EXPORTAÇÃO COM REDUÇÃO DE TAMANHO
        exportBtn.onclick = async () => {
            if (!audioBuffer) return;
            statusMsg.classList.remove('hidden');
            exportBtn.disabled = true;

            const rate = pS.value * tS.value;
            const format = document.getElementById('format').value;
            const duration = audioBuffer.duration / rate;
            
            // Forçamos 1 canal (Mono) para reduzir o tamanho pela metade
            const offlineCtx = new OfflineAudioContext(1, Math.floor(audioBuffer.sampleRate * duration), audioBuffer.sampleRate);

            const oSource = offlineCtx.createBufferSource();
            oSource.buffer = isReverse ? reverseBuffer(audioBuffer) : audioBuffer;
            oSource.playbackRate.value = rate;

            const oFilter = offlineCtx.createBiquadFilter(); oFilter.type = "lowpass"; oFilter.frequency.value = fS.value;
            const oDist = offlineCtx.createWaveShaper(); oDist.curve = makeDistortionCurve(dS.value);
            const oRev = offlineCtx.createConvolver(); oRev.buffer = createReverb();
            const oDry = offlineCtx.createGain(); const oWet = offlineCtx.createGain();
            oDry.gain.value = 1 - rS.value * 0.5; oWet.gain.value = rS.value;

            oSource.connect(oFilter); oFilter.connect(oDist); oDist.connect(oDry); oDry.connect(offlineCtx.destination);
            oDist.connect(oRev); oRev.connect(oWet); oWet.connect(offlineCtx.destination);
            oSource.start();

            try {
                const rendered = await offlineCtx.startRendering();
                let blob;
                if (format === 'mp3') {
                    // MP3 a 128kbps Mono é extremamente pequeno
                    blob = await encodeMP3(rendered, 128);
                } else {
                    // WAV Mono 16-bit
                    blob = bufferToWavMono(rendered);
                }

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `screw_mini_${Date.now()}.${format}`;
                a.click();
                
                setTimeout(() => window.URL.revokeObjectURL(url), 1000);

            } catch (err) {
                console.error("Erro na exportação:", err);
            } finally {
                statusMsg.classList.add('hidden');
                exportBtn.disabled = false;
            }
        };

        async function encodeMP3(ab, bitrate) {
            return new Promise(res => {
                // Encode em Mono (1 canal) para diminuir tamanho
                const mp3encoder = new lamejs.Mp3Encoder(1, ab.sampleRate, bitrate);
                const mp3Data = [];
                const samples = ab.getChannelData(0);
                
                const conv = (s) => {
                    const i16 = new Int16Array(s.length);
                    for (let i = 0; i < s.length; i++) {
                        let v = Math.max(-1, Math.min(1, s[i]));
                        i16[i] = v < 0 ? v * 0x8000 : v * 0x7FFF;
                    }
                    return i16;
                };
                
                const data = conv(samples), b = 1152;
                for (let i = 0; i < data.length; i += b) {
                    const buf = mp3encoder.encodeBuffer(data.subarray(i, i + b));
                    if (buf.length > 0) mp3Data.push(buf);
                }
                const end = mp3encoder.flush();
                if (end.length > 0) mp3Data.push(end);
                res(new Blob(mp3Data, { type: 'audio/mp3' }));
            });
        }

        function bufferToWavMono(ab) {
            // WAV Mono 16-bit (Redução drástica comparado ao estéreo 32-bit padrão)
            const n = 1; // Mono
            let len = ab.length * n * 2 + 44, b = new ArrayBuffer(len), v = new DataView(b), pos = 0;
            const u16 = (d) => { v.setUint16(pos, d, true); pos += 2; };
            const u32 = (d) => { v.setUint32(pos, d, true); pos += 4; };
            
            u32(0x46464952); u32(len - 8); u32(0x45564157); u32(0x20746d66); u32(16); u16(1); u16(n);
            u32(ab.sampleRate); u32(ab.sampleRate * 2 * n); u16(n * 2); u16(16); u32(0x61746164); u32(len - pos - 4);
            
            const data = ab.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                let s = Math.max(-1, Math.min(1, data[i]));
                v.setInt16(pos, (s < 0 ? s * 0x8000 : s * 0x7FFF), true); pos += 2;
            }
            return new Blob([b], {type: "audio/wav"});
        }
    </script>
</body>
</html>

